Node.js Writable Streams & Custom FileWriteStream – Detailed Notes

1️⃣ Basics: Objects, Classes, and Inheritance

Objects: Containers for data and behavior.

const person = {
     name: "Kavindu", 
     greet() { console.log("Hello " + this.name); } 
     };

person.greet(); // Hello Kavindu


Classes: Blueprints to create objects with shared behavior.

class Person {
  constructor(name) { this.name = name; }
  greet() { console.log("Hello " + this.name); }
}
const p = new Person("Kavindu");
p.greet();


Inheritance: Child classes can reuse behavior of parent classes.

class Employee extends Person {
  constructor(name, job) { super(name); this.job = job; }
}

2️⃣ Node.js Writable Streams

Writable streams allow writing data piece by piece, instead of all at once.

Default internal buffer size: 16 KB.

highWaterMark: Max bytes stored in buffer before write pauses.

const fs = require("fs");
const stream = fs.createWriteStream("file.txt");
console.log(stream.writableHighWaterMark); // 16 KB by default

3️⃣ Custom Writable Stream: FileWriteStream

const { Writable } = require("node:stream");
const fs = require("node:fs");


Writable: Base class for writable streams.

fs: File system module to read/write files.

3b: Define the Class

class FileWriteStream extends Writable {
  constructor({ highWaterMark, fileName }) {
    super({ highWaterMark });
    this.fileName = fileName;
    this.fd = null;
    this.chunks = [];
    this.chunksSize = 0;
    this.writesCount = 0;
  }
}


extends Writable → Inherits writable stream functionality.

this.chunks → Manual buffer for batching writes.

this.fd → File descriptor (open file handle).

this.writesCount → Number of times data was actually written to disk.

_construct Method

_construct(callback) {
  fs.open(this.fileName, "w", (err, fd) => {
    if (err) callback(err);
    else { this.fd = fd; callback(); }
  });
}


Runs after constructor, before _write, _final.

Opens the file.

callback(err) → lets Node know if file opened successfully.

 _write Method

_write(chunk, encoding, callback) {
  this.chunks.push(chunk);
  this.chunksSize += chunk.length;

  if (this.chunksSize > this.writableHighWaterMark) {
    fs.write(this.fd, Buffer.concat(this.chunks), (err) => {
      if (err) return callback(err);
      this.chunks = [];
      this.chunksSize = 0;
      ++this.writesCount;
      callback();
    });
  } else {
    callback();
  }
}


Called every time stream.write(chunk) is called.
Stores data in this.chunks until size > highWaterMark.
Then writes to file using fs.write().
Important: this.chunks ≠ Node’s internal buffer.
Node’s buffer exists automatically.
this.chunks is your manual batch buffer to reduce disk writes.

 _final Method

_final(callback) {
  fs.write(this.fd, Buffer.concat(this.chunks), (err) => {
    if (err) return callback(err);
    ++this.writesCount;
    this.chunks = [];
    callback();
  });
}


Called when .end() is used.
Writes any remaining buffered chunks to the file.

 _destroy Method

_destroy(error, callback) {
  console.log("Number of writes:", this.writesCount);
  if (this.fd) fs.close(this.fd, (err) => callback(err || error));
  else callback(error);
}


Runs after _final, cleans up resources.
Closes file descriptor and logs writes.

4️⃣ Using the Stream
const stream = new FileWriteStream({ highWaterMark: 1800, fileName: "text.txt" });

stream.write(Buffer.from("This is some string."));
stream.end(Buffer.from("Our last write."));

stream.on("finish", () => console.log("Stream was finished"));


write() → Adds chunks to Node’s buffer → _write → this.chunks → flushed if large.

end() → Triggers _final → flush remaining chunks → _destroy.

'finish' event → Fired after _final completes.

5️⃣ Flow of Data (Diagram)
          ┌─────────────────────┐
          │   stream.write()    │
          └─────────┬──────────┘
                    │
                    ▼
      ┌─────────────────────────────┐
      │ Node.js Internal Buffer     │  <-- 1800 bytes in custom stream
      └─────────┬─────────────────┘
                │
                ▼
      ┌─────────────────────────────┐
      │ _write(chunk) method         │
      └─────────┬─────────────────┘
                │
                ▼
      ┌─────────────────────────────┐
      │  this.chunks array           │  <-- Manual batch buffer
      │  Collect chunks until        │
      │  chunksSize > highWaterMark  │
      └─────────┬─────────────────┘
                │
                ▼
      ┌─────────────────────────────┐
      │  fs.write(fd, Buffer.concat(this.chunks)) │
      │  Data flushed to disk                        │
      └─────────────────────────────┘

6️⃣ Key Points

Node’s internal buffer = automatic, stores chunks temporarily.
this.chunks array = your manual batch buffer for optimized disk writes.

highWaterMark controls:

Node internal buffer
When you flush your manual chunks array
Always call callback() inside _write, _final, _destroy to signal completion.
_final ensures leftover chunks are written before stream ends.
_destroy cleans up resources and logs statistics.