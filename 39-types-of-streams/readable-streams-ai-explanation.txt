ğŸ“– Node.js Readable Streams â€“ Beginnerâ€™s Guide
ğŸ” What is a Readable Stream?

A Readable Stream is like a faucet that delivers data piece by piece instead of giving you the entire bucket at once.

You use it when data is too large to load into memory at once (e.g., big files, HTTP requests).

Example: fs.createReadStream("bigfile.txt")

âš™ï¸ How Readable Streams Work
Internal Buffer System

Readable streams also have an internal buffer.

The size is controlled by highWaterMark:

Default: 16 KB (16,384 bytes) for binary data

Or 16 objects in objectMode

Data Flow

Producer pushes data into the internal buffer (from file, network, etc.).

Consumer pulls data out by listening to events or calling methods.

ğŸ›  Two Ways to Consume Data
1. Event Mode (Flowing Mode)

You listen for the 'data' event:

const fs = require("fs");
const readable = fs.createReadStream("big.txt");

readable.on("data", (chunk) => {
  console.log("Got chunk:", chunk.length, "bytes");
});

readable.on("end", () => {
  console.log("No more data");
});


Node automatically pulls data and emits it in chunks (default 16 KB).

You just react to each 'data' event.

2. Manual Mode (Paused Mode)

You pull data manually using .read():

const fs = require("fs");
const readable = fs.createReadStream("big.txt");

readable.on("readable", () => {
  let chunk;
  while ((chunk = readable.read()) !== null) {
    console.log("Read:", chunk.length, "bytes");
  }
});


Gives you more control over how fast you consume data.

ğŸš¨ Why Streams Matter

Imagine a 800 MB file:

âŒ Without streams:

const data = fs.readFileSync("hugefile.txt");
// Loads entire 800MB into memory at once â†’ risk of crash


âœ… With streams:

const stream = fs.createReadStream("hugefile.txt");
stream.on("data", (chunk) => {
  // Only ~16KB in memory at a time
});


This way, you never hold the full file in memory, only one small piece at a time.

ğŸ”„ Piping Readable â†’ Writable

Streams work best when you connect a readable stream to a writable stream.

const fs = require("fs");
const readable = fs.createReadStream("big.txt");
const writable = fs.createWriteStream("copy.txt");

readable.pipe(writable);


Data flows chunk by chunk from input to output.

Backpressure is automatically managed.

ğŸ“¦ Duplex & Transform (Quick Note)

Duplex Stream: Can both read and write (e.g., TCP socket).

Transform Stream: Like Duplex but can modify data as it flows (e.g., compression, encryption).

These have two buffers: one for reading, one for writing.

ğŸ“ Key Takeaways

Readable streams deliver data in chunks (default 16 KB).

Two main modes: flowing (data events) and paused (read() method).

Great for large files, network requests, or continuous data.

Combine with Writable streams via .pipe() for efficient flow.

Helps prevent out-of-memory crashes.

âœ… Best Practice: If you need to move big data (files, HTTP responses, etc.), always use Readable + Writable streams instead of loading everything into memory.


 letâ€™s illustrate how a Readable Stream buffer works with a diagram.

ğŸ–¼ Readable Stream Buffer Diagram

Suppose you do:

const fs = require("fs");
const readable = fs.createReadStream("big.txt");

readable.on("data", (chunk) => {
  console.log("Got chunk:", chunk.length);
});

1ï¸âƒ£ Data Producer (File, Network, etc.)

Data comes from a source (like a file).

[ big.txt file ]  â†’  stream internal buffer

2ï¸âƒ£ Internal Buffer Queue (16KB by default)

As the file is read, data is pushed into the streamâ€™s internal buffer:

 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  Readable Stream Buffer      â”‚  (highWaterMark = 16KB default)
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Chunk: 16KB   â”‚   â”‚ Chunk: 16KB   â”‚   â”‚ Chunk: 16KB   â”‚ ...
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Each chunk is stored separately, just like in a Writable streamâ€™s buffer.

3ï¸âƒ£ Consumer Reads Data ('data' event)

When your code listens to 'data', Node delivers one chunk at a time:

[data event fired] â†’ delivers "chunk #1"
[data event fired] â†’ delivers "chunk #2"
[data event fired] â†’ delivers "chunk #3"
...

4ï¸âƒ£ End of Stream

When all chunks have been delivered:

[data event fired for last chunk]
[end event fired] â†’ No more data

ğŸ“Š Flow Summary
File (Producer) â†’ [Readable Buffer: chunk1 â†’ chunk2 â†’ chunk3 â€¦] â†’ App (Consumer via 'data')


âœ… Key Insight:

Each chunk you get from a Readable stream corresponds to an individual buffer entry inside the internal queue.

Theyâ€™re emitted one by one in order until the source is finished.


pipe a readable stream into a writable stream diagram

how piping works when you connect a Readable Stream to a Writable Stream.

ğŸ–¼ Pipe Diagram â€“ Readable â†’ Writable

Suppose you do:

const fs = require("fs");
const readable = fs.createReadStream("big.txt");   // Readable source
const writable = fs.createWriteStream("copy.txt"); // Writable destination

readable.pipe(writable);

1ï¸âƒ£ Data Source â†’ Readable Stream Buffer
[ big.txt file ] 
        â”‚
        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  Readable Buffer (16KB)     â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   chunk1 â†’ chunk2 â†’ chunk3 â†’ ...

2ï¸âƒ£ Pipe Connects to Writable Stream Buffer
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  Readable Buffer (16KB)     â”‚ --> â”‚ Writable Buffer (16KB)      â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   chunk1 â†’ chunk2 â†’ chunk3 ...       waiting to be flushed to file


Chunks flow in order from the readable buffer into the writable buffer.

3ï¸âƒ£ Backpressure Handling

If the writable buffer fills up (hits its highWaterMark),
the pipe pauses the readable stream.

Writable FULL â†’ pause reading ğŸš¦


When the writable buffer empties (after flushing to disk),
the pipe resumes reading.

Writable drained â†’ resume reading âœ…

4ï¸âƒ£ Destination (File, Socket, etc.)

Finally, chunks are flushed to the destination:

Readable â†’ Writable â†’ [ copy.txt file ]

ğŸ“Š Full Flow Summary
[ big.txt file ] 
   â”‚
   â–¼
Readable Stream Buffer (chunks) 
   â”‚
   â–¼
Pipe (manages flow & backpressure) 
   â”‚
   â–¼
Writable Stream Buffer (chunks) 
   â”‚
   â–¼
[ copy.txt file ]


âœ… Why pipe() is awesome:

Handles chunk transfer automatically.

Manages backpressure for you (pausing/resuming).

Efficient for large files, streams, or network data.